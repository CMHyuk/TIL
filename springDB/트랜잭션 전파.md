## 트랜잭션 전파
* 모든 논리 트랜잭션이 커밋돼야 물리 트랜잭션 커밋  
* 하나의 논리 트랜잭션 롤백 시 물리 트랜잭션 롤백  
* 요청 흐름  
   1. 외부 - 로직 A, 내부 - 로직 B 존재
   2. 외부 트랜잭션 시작 
   3. 데이터소스를 통해 커넥션 생성  
   4. 수동 커밋 모드로 설정 -> 물리 트랜잭션 시작  
   5. 트랜잭션 매니저가 트랜잭션 동기화 매니저에 커넥션 보관  
   6. 로직 A 사용 -> 커넥션 필요시 동기화 매니저를 통해 획득해 사용  
   7. 내부 트랜잭션 시작  
   8. 기존 트랜잭션 존재 확인 후 참여  
   9. 로직 B 사용 -> 내부 트랜잭션 커밋 or 롤백 (커밋은 실제 커밋 아님, 롤백 시 트랜잭션 동기화 매니저에 rollbackOnly=true로 표시)  
   -> 롤백 시 물리 트랜잭션 롤백 후 ```UnexpectedRollbackException``` 예외를 던짐
   10. 로직 A가 끝나고 외부 트랜잭션 커밋 or 롤백  
 
 </br>
 
## 외부 트랜잭션과 내부 트랜잭션 분리   
* ```@Transactional(propagation = Propagation.REQUIRES_NEW)```  
  * 외부 트랜잭션과 내부 트랜잭션을 완전히 분리해 사용하는 법  
  * 내부 트랜잭션이 롤백 되어도 외부 트랜잭션에 영향을 주지 않음(로직 B 롤백, 로직 A 커밋)  
  * ```REQUIRES_NEW``` 사용 시 하나의 HTTP 요청에 2개의 커넥션을 사용 성능 고려해 사용해야함  
* ```REQUIRES_NEW```를 사용하지 않고 구조 변경 -> 하나의 클래스를 추가해 따로 동작하도록 설계  

</br>  

## 전파 옵션
* REQUIRED  
  * 기본 설정 기존 트랜잭션 없으면, 생성 있으면 참여  
* REQUIRES_NEW  
  * 항상 새로운 트랜잭션을 생성  
* ```isolation``` , ```timeout``` , ```readOnly```는 트랜잭션 처음 시작될 때만 적용 참여 시 적용 x  

</br> 

출처 : 스프링 DB 2편 - 데이터 접근 활용 기술
